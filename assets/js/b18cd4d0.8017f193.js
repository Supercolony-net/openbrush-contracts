"use strict";(self.webpackChunkopenbrush=self.webpackChunkopenbrush||[]).push([[85176],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(a),h=o,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||r;return a?n.createElement(m,i(i({ref:t},u),{},{components:a})):n.createElement(m,i({ref:t},u))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8838:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(87462),o=(a(67294),a(3905));const r={sidebar_position:1,title:"Upgradeable contract"},i="Upgradeable contract",l={unversionedId:"smart-contracts/upgradeable",id:"smart-contracts/upgradeable",title:"Upgradeable contract",description:"Overview",source:"@site/docs/smart-contracts/upgradeable.md",sourceDirName:"smart-contracts",slug:"/smart-contracts/upgradeable",permalink:"/next/smart-contracts/upgradeable",draft:!1,editUrl:"https://github.com/Supercolony-net/openbrush-contracts/tree/main/docs/docs/smart-contracts/upgradeable.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Upgradeable contract"},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/next/smart-contracts/overview"},next:{title:"Access Control",permalink:"/next/smart-contracts/access-control/"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Storage layout",id:"storage-layout",level:2},{value:"How storage works",id:"how-storage-works",level:3},{value:"Rules for upgradeable storage layout",id:"rules-for-upgradeable-storage-layout",level:3},{value:"Suggestions on how follow the rules",id:"suggestions-on-how-follow-the-rules",level:3},{value:"Approach description",id:"approach-description",level:4},{value:"Logic unit per business use case",id:"logic-unit-per-business-use-case",level:4},{value:"Limitations for future upgrades",id:"limitations-for-future-upgrades",level:5},{value:"Logic unit per each field",id:"logic-unit-per-each-field",level:4},{value:"Unique storage key",id:"unique-storage-key",level:4},{value:"Constructor and initialization",id:"constructor-and-initialization",level:2},{value:"Initialization method",id:"initialization-method",level:3},{value:"Delegate call",id:"delegate-call",level:4},{value:"Workaround",id:"workaround",level:4},{value:"Initialization state per logic unit",id:"initialization-state-per-logic-unit",level:4},{value:"Permission to initialize",id:"permission-to-initialize",level:4},{value:"Small optimization for all upgradeable contract",id:"small-optimization-for-all-upgradeable-contract",level:3},{value:"Types of upgradeable contracts",id:"types-of-upgradeable-contracts",level:2},{value:"The <code>Proxy</code> Pattern",id:"the-proxy-pattern",level:3},{value:"Usage of <code>set_code_hash</code> method",id:"usage-of-set_code_hash-method",level:3},{value:"The <code>Diamond</code> Standard",id:"the-diamond-standard",level:3},{value:"Logic units for facet",id:"logic-units-for-facet",level:4},{value:"Definition of the facet (logic layer)",id:"definition-of-the-facet-logic-layer",level:4},{value:"Interaction between facets",id:"interaction-between-facets",level:4},{value:"Cross-contract call to itself",id:"cross-contract-call-to-itself",level:5},{value:"Embed logic unit",id:"embed-logic-unit",level:5},{value:"Remark about logic units and OpenBrush",id:"remark-about-logic-units-and-openbrush",level:5}],u={toc:c};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"upgradeable-contract"},"Upgradeable contract"),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Smart contracts are immutable by default, adding a layer of security and trust to the\ncontracts. But software quality depends on the ability to upgrade source code to\nproduce iterative releases. A certain degree of mutability is needed for bug fixing\nand potential product improvements."),(0,o.kt)("p",null,"Upgradeability allows experimenting and deploying the product at the early stage,\nalways leaving the chance to fix vulnerabilities and progressively add features.\nIt is more actual right now while ink! and contract-pallet are under active development.\nUpgradeable contracts are not a Bug if they are developed consciously with\ndecentralization in mind."),(0,o.kt)("p",null,"Decentralization can be achieved by providing the right to upgrade only to\ndecentralized authority like governance, multisig, or another analog."),(0,o.kt)("p",null,"It is not hard to upgrade the logic of contracts. It can be achieved via ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond"),"\npatterns or via the ",(0,o.kt)("inlineCode",{parentName:"p"},"set_code_hash")," function provided by contract-pallet. The hardest\npart is to save the contract's state and make it compatible with new logic."),(0,o.kt)("h2",{id:"storage-layout"},"Storage layout"),(0,o.kt)("h3",{id:"how-storage-works"},"How storage works"),(0,o.kt)("p",null,"Contracts use key-value storage to persist data. Each field of the contract may have\nits key and occupy storage cell. It is called storage layout."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(42585).Z,width:"1172",height:"646"})),(0,o.kt)("p",null,"During compilation ink! inserts code to work with storage and ink! knows how to store\neach type in which storage cell. How exactly it works is not a part of this tutorial.\nThe main point is that each type knows how to operate with each field and operate with\nstorage, because of a unique identifier. In the old version of ink! the identifier is\n",(0,o.kt)("inlineCode",{parentName:"p"},"[u8; 32]")," in a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1134"},"new version")," it is ",(0,o.kt)("inlineCode",{parentName:"p"},"u32"),"."),(0,o.kt)("p",null,"So, each data is stored under its unique identifier - the storage key. The value of the\nkey is the sequence of bytes - serialized (by SCALE codec) data type. The logic layer\nknows how to serialize and deserialize each data type. So during the execution, the\nlogic layer deserializes all data by their storage keys and returns the\nfilled contract's storage variable. The developer works with that variable, and before\nthe end of the execution, the logic layer serializes data into sequences of bytes and\nstores them in their storage cells."),(0,o.kt)("h3",{id:"rules-for-upgradeable-storage-layout"},"Rules for upgradeable storage layout"),(0,o.kt)("p",null,"The contract can have several logic layers (like in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," pattern).\nSo we will define rules in terms of several layers, but it is also applicable\nfor upgradeable contracts with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," pattern or ",(0,o.kt)("inlineCode",{parentName:"p"},"set_code_hash"),"."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The data stored under the storage key should use the same serialization and\ndeserialization mechanism across all logic layers. Otherwise, some logic layers will not\nbe able to deserialize the data type and fail."),(0,o.kt)("li",{parentName:"ol"},"Each logic unit (in most cases, it is a type) should occupy the same storage key across\nall logic layers. For example, you have several logic layers that use the\n",(0,o.kt)("inlineCode",{parentName:"li"},"Mapping<Owner, Balances>")," to track users' balances. You should use the same storage\nkey if you want to interact with the same mapping. Otherwise, you will work with different mappings."),(0,o.kt)("li",{parentName:"ol"},"Each field that occupies some storage key should be used only in its usage flow.\nFor example, you have ",(0,o.kt)("inlineCode",{parentName:"li"},"Mapping<Owner, Balances>")," to track users' balances of token\nA in one logic layer. You can't use it in another logic layer to track users'\nbalances of token B. Otherwise, one logic layer can overwrite another.")),(0,o.kt)("p",null,"Following those simple rules will save you from corrupting the storage.\nThose rules are applicable for upgraded logic layers too."),(0,o.kt)("p",null,"If you use the same storage layout across all logic layers, and you don't plan to have\nunique fields per layer(so you don't plan to modify the storage layout in future upgrades).\nThen you already follow those rules with automatically calculated storage keys.\nBut if you want to use a unique layout per layer or\nplan to modify the layout in the future, the next section will help you."),(0,o.kt)("h3",{id:"suggestions-on-how-follow-the-rules"},"Suggestions on how follow the rules"),(0,o.kt)("h4",{id:"approach-description"},"Approach description"),(0,o.kt)("p",null,"The manual setting of the storage key for each field allows following the rules but\nmakes development harder. ink! allows you to manually implement all utility traits and\nspecify the storage key you want to use for each field. If your contract has 20 fields,\nthen you need to set 20 storage keys."),(0,o.kt)("p",null,"The main suggestion is to design your storage layout as a bunch of logic units and\nassign a unique storage key to logic unit. The logic unit can be one field or a bunch\nof fields. In the scope of the logic unit, you can use automatically calculated keys\noffset with the storage key of the logic unit, or you can use the same approach\nagain and split logic into more units."),(0,o.kt)("p",null,"With this approach, you can order your units as you wish. You can add/remove/swap\nlogic units and don't worry about storage layout because each logic unit will have its space\nin the blockchain's storage. If storage keys are unique, those spaces don't overlap."),(0,o.kt)("p",null,"OpenBrush provides ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts/blob/main/lang/macro/src/lib.rs#L447"},(0,o.kt)("inlineCode",{parentName:"a"},"openbrush::upgradeable_storage")),"\nattribute macro that implements all required traits with specified storage key(storage key is required input argument to macro).\nAlso, macro initializes the field with a default value if the field is not initialized before\n(it can be actual during the upgrade because new fields are not initialized yet).\nYou can use that macro to define a logic unit."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": Each logic unit should have a unique storage key.\nThe storage key should be used only once in the contract.\nThose two requirements mean that your type(logic unit) can be used only once in the contract. For example,\n",(0,o.kt)("inlineCode",{parentName:"p"},"psp22::Data")," is a logic unit. You can have only one field of that type.\nIf you have several fields with that type, you will use the same storage\nkey several times, which is a collision.")),(0,o.kt)("h4",{id:"logic-unit-per-business-use-case"},"Logic unit per business use case"),(0,o.kt)("p",null,"You can include all fields into logic unit, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::upgradeable_storage(0x123)]\npub struct Data {\n    balances: Mapping<Owner, Balance>,\n    total_owners: u128,\n}\n")),(0,o.kt)("p",null,"It makes your code readable and segregated by business logic.\nBut it will add some limitations to future upgrades."),(0,o.kt)("h5",{id:"limitations-for-future-upgrades"},"Limitations for future upgrades"),(0,o.kt)("p",null,"Each field that doesn't have a separate space in the storage almost always depends\non the field ordering(and maybe naming if you use a new ink!). So you can't remove\nfields or change the ordering(and naming). "),(0,o.kt)("p",null,"But you can add new fields. For that, you can reserve one field with empty type ",(0,o.kt)("inlineCode",{parentName:"p"},"Option<()>"),"\nin your contract for future type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::upgradeable_storage(0x123)]\npub struct Data {\n    balances: Mapping<Owner, Balance>,\n    total_owners: u128,\n    _reserved: Option<()>,\n}\n")),(0,o.kt)("p",null,"The default value of that field is ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),". But in the future, you can init it with some useful type and value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::upgradeable_storage(0x123)]\npub struct Data {\n    balances: Mapping<Owner, Balance>,\n    total_owners: u128,\n    _reserved: Option<DataExtend>,\n}\n\nimpl Data {\n    fn extension(&mut self) -> &mut DataExtension {\n        &mut self._reserved.unwrap_or_default()\n    }\n}\n\n#[derive(Default)]\npub struct DataExtension {\n  owners_blacklist: Mapping<Owner, ()>,\n  _reserved: Option<()>,\n}\n")),(0,o.kt)("p",null,"So if you modify your contract many times in the future,\nit can cause a deep stack of ",(0,o.kt)("inlineCode",{parentName:"p"},"_reserved")," fields, or many dead fields.\nYou can always create a new logic unit and embed the old one. So you should decide what\nis better for you right now. Create a new logic unit that will include the old one,\nor add a new field into the current."),(0,o.kt)("h4",{id:"logic-unit-per-each-field"},"Logic unit per each field"),(0,o.kt)("p",null,"You can create a unique type for each field like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::upgradeable_storage(0x123)]\npub struct Balances(openbrush::storage::Mapping<AccountId, Balance>);\n\n#[openbrush::upgradeable_storage(0x124)]\npub struct TotalOwners(u128);\n")),(0,o.kt)("p",null,"You have no limitations, but you made your code harder to read,\nand maybe you have a lot of unique structures :D"),(0,o.kt)("h4",{id:"unique-storage-key"},"Unique storage key"),(0,o.kt)("p",null,"The storage key should be unique per each logic unit. You can assign each key manually or\nuse some hash function to automate it."),(0,o.kt)("p",null,"OpenBrush provides ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts/blob/main/lang/src/macros.rs#L25"},(0,o.kt)("inlineCode",{parentName:"a"},"openbrush::storage_unique_key!")),"\nmacro that generates a storage key based on the path to the structure.\nIt has one required input argument - the name of the structure."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::upgradeable_storage(openbrush::storage_unique_key!(Data))]\npub struct Data {\n    balances: Mapping<Owner, Balance>,\n    total_owners: u128,\n    _reserved: Option<()>,\n}\n")),(0,o.kt)("p",null,"or "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub const STORAGE_KEY: u32 = openbrush::storage_unique_key!(Data);\n\n#[openbrush::upgradeable_storage(STORAGE_KEY)]\npub struct Data {\n    balances: Mapping<Owner, Balance>,\n    total_owners: u128,\n    _reserved: Option<()>,\n}\n")),(0,o.kt)("h2",{id:"constructor-and-initialization"},"Constructor and initialization"),(0,o.kt)("p",null,"Uploading your contract on the blockchain with ",(0,o.kt)("inlineCode",{parentName:"p"},"contract-pallet")," has two phases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Deploy - deploys source code to the blockchain. After deploying, the network uses the hash of the source code as an identifier for future instantiation of the contract. Now anyone can instantiate the contract by source code hash."),(0,o.kt)("li",{parentName:"ul"},"Instantiation - creates the instance of the contract on the blockchain that uses source code by its hash. After that, anyone can interact with the contract.")),(0,o.kt)("p",null,"So, deploy - uploading a logic layer to the blockchain; instantiation - reservation of\nthe storage that belongs to the contract and creation of the entity to\ninteract(contract with ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountId"),") with that storage via logic layers."),(0,o.kt)("p",null,"Each logic layer can require initialization to set up initial variables for correct\nwork. In the typical scenario, when the contract is not upgradeable, you have only\none logic layer, which should be initialized only once during the instantiation of\nthe contract. It is called a constructor. You still can have several constructors,\nbut you can call only one during instantiation."),(0,o.kt)("p",null,"Constructors can still be used to initialize upgradeable contracts that use the\n",(0,o.kt)("inlineCode",{parentName:"p"},"set_code_hash")," function. But that approach doesn't work for logic layers of\n",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," patterns."),(0,o.kt)("h3",{id:"initialization-method"},"Initialization method"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," pattern contracts have their constructor but only initialize\nvariables related to forwarding calls to corresponding logic layers."),(0,o.kt)("h4",{id:"delegate-call"},"Delegate call"),(0,o.kt)("p",null,"Those contracts use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/issues/10566"},(0,o.kt)("inlineCode",{parentName:"a"},"delegate_call"))," to forward calls to logic layers.\nThe delegate call accepts the logic layer's code hash and executes the source code, corresponding to the hash,\nin the context of the current contract. The source code works with the current contract state in that case.\nYou can't call the constructor during a delegate call, so you can't naturally initialize the contract."),(0,o.kt)("h4",{id:"workaround"},"Workaround"),(0,o.kt)("p",null,"Instead of using the constructors as the primary way to initialize the logic\nunits(each logic layer has its logic unit or a bunch of logic units),\nyou can add a separate initializer method and leave the constructor empty(with\nresolving ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1187"},"issue")," you can not\nhave constructor at all). That initialize method can accept any arguments the\nsame as a typical constructor."),(0,o.kt)("p",null,"For example, for an upgradeable ",(0,o.kt)("inlineCode",{parentName:"p"},"PSP22")," contract, you can add the ",(0,o.kt)("inlineCode",{parentName:"p"},"init_with_supply")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message)]\npub fn init_with_supply(&mut self, total_supply: Balance) -> Result<(), PSP22Error> {\n    self._mint_to(Self::env().caller(), total_supply)\n}\n")),(0,o.kt)("p",null,"You can add as many methods as you wish with any arguments (the same as constructors).\nThe problem is that anyone can call all those methods unlimited times when the\nconstructor can be called once by the creator of the contract.\nIn most cases, you want the same behavior as a constructor.\nSo you need to add the check that initialization already was called and\nrestrict the set of people that can do that."),(0,o.kt)("h4",{id:"initialization-state-per-logic-unit"},"Initialization state per logic unit"),(0,o.kt)("p",null,"Each logic unit can store boolean variable that shows the state of initialization."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(message)]\npub fn init_with_supply(&mut self, total_supply: Balance) -> Result<(), PSP22Error> {\n    if self.initialized {\n        return Err(PSP22Error::Custom(String::from("Already initialized")));\n    }\n    self._mint_to(Self::env().caller(), total_supply)\n}\n')),(0,o.kt)("h4",{id:"permission-to-initialize"},"Permission to initialize"),(0,o.kt)("p",null,"Also, you can use some logic to manage permission. In an upgradeable contract,\nyou should already use some logic to manage upgrades. You can reuse it here.\nIf you use ",(0,o.kt)("inlineCode",{parentName:"p"},"Ownable")," then the code can look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink(message)]\n#[openbrush::modifiers(only_owner)]\npub fn init_with_supply(&mut self, total_supply: Balance) -> Result<(), PSP22Error> {\n    if self.initialized {\n        return Err(PSP22Error::Custom(String::from("Already initialized")));\n    }\n    self._mint_to(Self::env().caller(), total_supply)\n}\n')),(0,o.kt)("p",null,"OpenBrush doesn't provide any utils for initialization right now because,\nin most cases, you have a unique way to initialize the contract.\nOpenBrush team doesn't want to add overhead - boolean variables per logic unit."),(0,o.kt)("p",null,"But for managing the permission, you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Ownable")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"AccessControl")," default implementation."),(0,o.kt)("h3",{id:"small-optimization-for-all-upgradeable-contract"},"Small optimization for all upgradeable contract"),(0,o.kt)("p",null,"Most contracts require initialization, but in most cases, only once.\nAfter initialization, you can always upgrade your contract and exclude the\ninitialization logic. It will make your contracts safer, improve performance,\nand reduce gas consumption."),(0,o.kt)("h2",{id:"types-of-upgradeable-contracts"},"Types of upgradeable contracts"),(0,o.kt)("p",null,"There are 3 types of Upgradeable contract."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Proxy")," pattern")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pros",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Basic pattern where it's hard to introduce a bug"))),(0,o.kt)("li",{parentName:"ul"},"Cons",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Necessity to deploy extra contract and additional overhead for every singe call")))),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Usage of ",(0,o.kt)("strong",{parentName:"li"},"set_code_hash")," method")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pros",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Easy to make your contract upgradeable, you only need to expose the ",(0,o.kt)("inlineCode",{parentName:"li"},"set_code_hash")," method"))),(0,o.kt)("li",{parentName:"ul"},"Cons",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If you forget to expose it during the update, you will lose the ability to do upgrades")))),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Diamond standard")," pattern")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pros",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Allows splitting your contract on facets(logic layers) to optimize performance of your contract and overcome contract size limits"),(0,o.kt)("li",{parentName:"ul"},"Allows upgrading facets(logic layers) separately and use different governance rules per logic layer"))),(0,o.kt)("li",{parentName:"ul"},"Cons",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"More overhead for particular overlapping logic units"),(0,o.kt)("li",{parentName:"ul"},"More likely to break the storage"),(0,o.kt)("li",{parentName:"ul"},"Requires good deploy management")))),(0,o.kt)("h3",{id:"the-proxy-pattern"},"The ",(0,o.kt)("inlineCode",{parentName:"h3"},"Proxy")," Pattern"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),' pattern has two contracts. The first contract is a simple wrapper -\na "proxy" that users interact with directly and is in charge of forwarding calls to\nthe second contract - the logic layer. The logic layer can be replaced while the proxy\ncan not. To upgrade the logic layer, you must replace the code hash of logic layer with a new one.'),(0,o.kt)("p",null,"The proxy contract is not upgradeable and straightforward. You can reuse implementation from OpenBrush to create your proxy.\nThe logic layer is better to follow the rules described above."),(0,o.kt)("p",null,"This is the illustration how ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," contract with delegate_call looks like:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(98528).Z,width:"1100",height:"238"})),(0,o.kt)("p",null,"OpenBrush provides default implementation for ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," pattern.\nIt has ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy::Data")," logic unit that stores ",(0,o.kt)("inlineCode",{parentName:"p"},"forward_to")," inside.\nThe storage unit occupies the ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy::STORAGE_KEY")," storage key.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"forward_to")," is the code hash of the logic layer's source code. It also contains\n",(0,o.kt)("inlineCode",{parentName:"p"},"change_delegate_call")," method to update code hash for ",(0,o.kt)("inlineCode",{parentName:"p"},"forward_to")," value inside\nthe contract. Only the owner is able to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"change_delegate_call")," method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub const STORAGE_KEY: u32 = openbrush::storage_unique_key!(Data);\n\n#[derive(Default, Debug)]\n#[openbrush::storage(STORAGE_KEY)]\npub struct Data {\n    pub forward_to: Hash,\n}\n")),(0,o.kt)("p",null,"For more details on how to reuse the default ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," implementation, you can check ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/proxy"},"Proxy"),"."),(0,o.kt)("p",null,"The logic layer for ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," is the same as the definition of the facet for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond"),"\ncontract, but you have only one facet. You can read about it in ",(0,o.kt)("a",{parentName:"p",href:"#logic-units-for-facet"},"that section"),". "),(0,o.kt)("h3",{id:"usage-of-set_code_hash-method"},"Usage of ",(0,o.kt)("inlineCode",{parentName:"h3"},"set_code_hash")," method"),(0,o.kt)("p",null,"ink! has the ",(0,o.kt)("inlineCode",{parentName:"p"},"ink_env::set_code_hash")," method, which allows replacing the code hash\nof the current contract. So you can change the logic layer by specifying a new code\nhash on demand. After setting a new code hash, the next call to your contract will execute updated logic."),(0,o.kt)("p",null,"You only need to expose that method somehow, and your common contract is upgradeable.\nFor example, you can add that method, and it is done:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message)]\npub fn upgrade_my_contract(&mut self, new_code_hash: Hash) {\n    ink_env::set_code_hash(&new_code_hash)\n}\n")),(0,o.kt)("p",null,"You need to consider the permission system because only a restricted set of people\nshould be able to call that function."),(0,o.kt)("p",null,"All suggestions described above are applicable for that kind of upgradeable contracts.\nBetter to have an upgradeable storage layout, initialization function for new versions\nof your contract, permission system, etc."),(0,o.kt)("h3",{id:"the-diamond-standard"},"The ",(0,o.kt)("inlineCode",{parentName:"h3"},"Diamond")," Standard"),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," Standard you can add support for several facets(logic layers) that\ncan be upgraded. ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2535"},"This standard")," came\nfrom the ethereum network. It works in the same way in ink! but instead of the\naddress of the logic layer, you need to use the code hash of the logic layer."),(0,o.kt)("p",null,"This is the illustration of the flow of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," pattern:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(28405).Z,width:"1075",height:"423"})),(0,o.kt)("p",null,"Each method in the smart contract has a selector. It is used as an identifier during the\nsmart contract call to execute the right logic.\nEach facet has a list of selectors that describe which methods are supported by the facet.\nEach selector is unique and belongs only to one facet. So selectors of facets can't overlap.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," contract knows which facet is responsible for which selector and forwards each\ncall to the smart contract to the corresponding facet (logic layer).\n",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," contract has a function ",(0,o.kt)("inlineCode",{parentName:"p"},"diamond_cut")," that allows registering each facet."),(0,o.kt)("p",null,"OpenBrush provides default implementation for ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," standard on ink!.\nFor more details you can check ",(0,o.kt)("a",{parentName:"p",href:"/next/smart-contracts/diamond/"},"Diamond"),"."),(0,o.kt)("p",null,"All suggestions above ideally describe how to develop an upgradeable contract\nwith multi-logic layers and many logic units.\nSo here we will describe how to write facets (logic layers) with OpenBrush."),(0,o.kt)("h4",{id:"logic-units-for-facet"},"Logic units for facet"),(0,o.kt)("p",null,"Each facet (logic layer) can have zero, one, or many logic units that work\nwith storage."),(0,o.kt)("p",null,"Each logic unit should have a unique storage key and be upgradeable (support initialization\non demand, use storage key as an offset for all inner fields). It can be a struct with\none or many fields (structs without fields are useless) or an enum with at least two\nvariants (an enum with one variant is a structure). You can define struct/enum with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"openbrush::upgradeable_storage")," macro and have an independent logic unit. You can\ncreate several units and combine them into one contract."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": If your contract has at least one field that is not defined with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"openbrush::upgradeable_storage"),", it will fail during execution. Each field should be\nupgradeable in the facet.")),(0,o.kt)("p",null,"As an example, we will define logic units for ",(0,o.kt)("inlineCode",{parentName:"p"},"PSP22")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Ownable")," facets."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// OpenBrush uses the same logic unit for the default implementation of the `PSP22` trait.\n#[openbrush::upgradeable_storage(openbrush::storage_unique_key!(PSP22Data))]\npub struct PSP22Data {\n    // Total supply of the `PSP22`\n    pub supply: Balance,\n    // Balance of each user\n    pub balances: Mapping<AccountId, Balance>,\n    // Allowance to send tokens from one user to another\n    pub allowances: Mapping<(AccountId, AccountId), Balance>,\n    // Reserved fields for future upgrades\n    pub _reserved: Option<()>,\n}\n\n// OpenBrush uses the same logic unit for the default implementation of the `Ownable` trait.\n// It simply stores the `AccountId` of the owner of the contract.\n#[openbrush::upgradeable_storage(openbrush::storage_unique_key!(OwnableData))]\npub struct OwnableData {\n    // Owner of the contract\n    pub owner: AccountId,\n    // Reserved fields for future upgrades\n    pub _reserved: Option<()>,\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PSP22Data")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"OwnableData")," have their storage keys. Both contain an additional field\nunrelated to business logic ",(0,o.kt)("inlineCode",{parentName:"p"},"_reserved")," for future upgrades(it adds overhead in one byte)."),(0,o.kt)("h4",{id:"definition-of-the-facet-logic-layer"},"Definition of the facet (logic layer)"),(0,o.kt)("p",null,"The definition of the facet is the same as the definition of the contract. You need\nto combine your logic units in the contract as fields. Leave the constructor empty,\nadd the initialization method and methods related to business logic."),(0,o.kt)("p",null,"Example uses logic units defined in the previous section."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[openbrush::contract]\npub mod facet_a {\n    ...\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct FacetA {\n        psp22: PSP22Data,\n        ownable: OwnableData,\n    }\n    \n    // Your own implementation of `PSP22` trait.\n    impl PSP22 for FacetA {\n        ...\n        \n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance {\n            ...\n        }\n    }\n\n    impl FacetA {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // Empty constructor, we do here nothing\n            ink_lang::codegen::initialize_contract(|instance: &mut Self| {})\n        }\n\n        // Initialization method to grant `total_supply` tokens to someone.\n        #[ink(message)]\n        pub fn init_with_supply(&mut self, total_supply: Balance) {\n            assert_eq!(Self::env().caller(), self.ownable.owner, "Only owner can init contract");\n            ...\n        }\n    }\n}\n')),(0,o.kt)("p",null,"You can deploy the code of the facet to the blockchain. After that, you can\nregister your facet in ",(0,o.kt)("inlineCode",{parentName:"p"},"Diamond")," via the ",(0,o.kt)("inlineCode",{parentName:"p"},"diamond_cut")," method or in ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy")," via\n",(0,o.kt)("inlineCode",{parentName:"p"},"change_delegate_call")," method."),(0,o.kt)("h4",{id:"interaction-between-facets"},"Interaction between facets"),(0,o.kt)("p",null,"During development, you can have cases when one logic layer (for example ",(0,o.kt)("inlineCode",{parentName:"p"},"FacetA"),") needs to interact with\nanother logic unit or logic layer (for example ",(0,o.kt)("inlineCode",{parentName:"p"},"FacetB"),").\nYou have two options for how to do that:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The contract can send a cross-contract call to itself and execute the public function(method marked with ",(0,o.kt)("inlineCode",{parentName:"li"},"#[ink(message)]"),") of your contract."),(0,o.kt)("li",{parentName:"ol"},"Embed logic unit into your contract what you want to use into another facet and interact with it.")),(0,o.kt)("h5",{id:"cross-contract-call-to-itself"},"Cross-contract call to itself"),(0,o.kt)("p",null,"If your ",(0,o.kt)("inlineCode",{parentName:"p"},"FacetA")," implements some trait, then you can use the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts#wrapper-around-traits"},"wrapper around trait"),"\nfeature of OpenBrush to do cross-contract call."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": The trait should be defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"openbrush::trait_definition"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::contract]\npub mod facet_b {\n    ...\n    \n    impl FacetB {\n        ...\n\n\n        #[ink(message)]\n        fn balance_of_owner_in_facet_a(&self, owner: AccountId) -> Balance {\n            let address_of_current_contract = Self::env().account_id();\n            // It does a cross-contract call to itself with `owner` as an argument.\n            // It needs to allow reentrancy if it wants to execute itself.\n            PSP22Ref::balance_of_builder(&address_of_current_contract, owner)\n                .call_flags(ink_env::CallFlags::default().set_allow_reentry(true))\n                .fire()\n                .unwrap();\n\n        }\n    }\n}\n")),(0,o.kt)("p",null,"The important thing is that you should allow reentrancy during that call.\nYou can also import the code of ",(0,o.kt)("inlineCode",{parentName:"p"},"FacetA")," and use the native ",(0,o.kt)("inlineCode",{parentName:"p"},"Ref")," feature for\ncross-contract calls of ink!."),(0,o.kt)("p",null,"Better to avoid the usage of cross-contract calls and work directly with the logic unit.\nBut it depends on the complexity of the logic layer."),(0,o.kt)("h5",{id:"embed-logic-unit"},"Embed logic unit"),(0,o.kt)("p",null,"If you use OpenBrush and follow suggestions above, your logic units are independent.\nIt allows you to embed any logic unit into any facet(logic layer) without corruption of the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::contract]\npub mod facet_b {\n    ...\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct FacetB {\n        // You embed `PSP22Data` logic unit from `FacetA`. \n        // It works with the same storage as `FacetA`. \n        // So you have access to data of `FacetA`.\n        psp22: PSP22Data,\n        // Some data for `FacetB`.\n        foo: BarData,\n    }\n\n    impl FacetB {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // Empty constructor, we do here nothing\n            ink_lang::codegen::initialize_contract(|instance: &mut Self| {})\n        }\n\n        #[ink(message)]\n        fn balance_of_owner_in_facet_a(&self, owner: AccountId) -> Balance {\n            // It accesses to the balance of `owner` that is managed by `FacetA`.\n            self.psp22.balances.get(&owner).unwrap_or_default()\n        }\n    }\n}\n")),(0,o.kt)("p",null,"Embedding of the logic unit grants access to its storage."),(0,o.kt)("h5",{id:"remark-about-logic-units-and-openbrush"},"Remark about logic units and OpenBrush"),(0,o.kt)("p",null,"All data structures for contracts provided by OpenBrush are upgradeable logic units.\nSo contracts support upgradeability by default."),(0,o.kt)("p",null,"You can access the default implementation when you embed OpenBrush data structures\ninto your contract. You can use default implementation internally, or you can make\nit public."),(0,o.kt)("p",null,"For example, when you embed ",(0,o.kt)("inlineCode",{parentName:"p"},"psp22::Data")," into your ",(0,o.kt)("inlineCode",{parentName:"p"},"Contract"),", you can already\ninternally use the methods of the ",(0,o.kt)("inlineCode",{parentName:"p"},"PSP22")," trait. Implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"PSP22")," makes your method public."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"impl PSP22 for Contract {} // That line makes your method publicly available.\n")),(0,o.kt)("p",null,"So, if you embed ",(0,o.kt)("inlineCode",{parentName:"p"},"psp22:Data")," in your ",(0,o.kt)("inlineCode",{parentName:"p"},"FacetB")," contract. Then you can call ",(0,o.kt)("inlineCode",{parentName:"p"},"self.balance_of(owner)")," and it will use the default implementation without a cross-contract call."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Code of facet A\n#[openbrush::contract]\npub mod facet_a {\n    use openbrush::contracts::psp22::*;\n    use openbrush::contracts::ownable::*;\n    ...\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct FacetA {\n        psp22: psp22::Data,\n        ownable: ownable::Data,\n    }\n\n    impl PSP22 for FacetA {}\n\n    impl FacetA {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // Empty constructor, we do here nothing\n            ink_lang::codegen::initialize_contract(|instance: &mut Self| {})\n        }\n\n        // Initialization method to grant `total_supply` tokens to someone.\n        #[ink(message)]\n        pub fn init_with_supply(&mut self, total_supply: Balance) {\n            assert_eq!(Self::env().caller(), self.ownable.owner, "Only owner can init contract");\n            ...\n        }\n    }\n}\n\n// Code of facet B\n#[openbrush::contract]\npub mod facet_b {\n    use openbrush::contracts::psp22::*;\n    ...\n\n    #[ink(storage)]\n    #[derive(SpreadAllocate)]\n    pub struct FacetB {\n        // The same logic unit is used in `FacetA`.\n        psp22: psp22::Data,\n        // Some data for `FacetB`.\n        foo: BarData,\n    }\n\n    impl FacetB {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // Empty constructor, we do here nothing\n            ink_lang::codegen::initialize_contract(|instance: &mut Self| {})\n        }\n\n        #[ink(message)]\n        fn balance_of_owner_in_facet_a(&self, owner: AccountId) -> Balance {\n            // Use default implementation for `psp22::Data`.\n            // It is not public, because it doesn\'t have `impl PSP22 for FacetB {}`\n            self.balance_of(owner)\n        }\n        \n        ...\n    }\n}\n')))}p.isMDXComponent=!0},28405:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20220715_130335_47FD0F8D-60F3-4FDF-82F4-672402FDC5D1-a624e080d2befeb98980a55ee14afac4.jpeg"},98528:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20220715_130416_DD058578-67E2-4832-9F75-CA18C3B3921C_4_5005_c-67091595b6efebada8fa49b9722adbe4.jpeg"},42585:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/20220719_075309_F016550A-65D2-4DCD-A60A-D1A70B38D813-fe0ee8a2bc13b4065a7fdfc597c407ab.jpeg"}}]);